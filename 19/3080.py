from functools import lru_cahce # Эта очень полезная функция, которая может пригодиться не только тут, но и в 16


def m(h): # Эта функция генерит все возможные ходы из позиции, которую в неё передали (позиция это число), эта функция меняеться в зависимости от задачи
    return h+1, h+2, h+3, h*2

@lru_cache(None)
# в этой фунуции меняеться только условие, при котором возвращается w
def g(h): # тут сама логика задачи, на вход она принимает позицию (сколько сейчас камней в куче) и возвращает исход игры при этой позиции
    if h > 37: # если кол-во камней больше чем нужно для победы, то мы победили (w)
        return 'w'
    if any(g(i) == 'w' for i in m(h)): # если один из ходов ведёт к победе, то это победа первым ходом (p1)
        return 'p1'
    if all(g(i) == 'p1' for i in m(h)): # если все ходы ведут к p1, то это проигрыш первым ходом (v1)
        return 'v1'
    if any(g(i) == 'v1' for i in m(h)): # если все ходы ведут в v1, то это победа вторым ходом (p2)
        return 'p2'
    if all((g(i) == 'p1' or g(i) == 'p2') for i in m(h)): # если все ходы ведут  к p1 и/или p2, то это проигрыш вторым ходом (v2)
        return 'v2'

# Тут надо менять в зависимости от вопроса
for s in range(1, 40): # тут всё зависит от задачи, в данном случае программа выведет все проигрыши вторым ходом (p2)
    if g(s) == 'v2':
        print(s)


#19: 18
#20: 9 17
#21: 14




